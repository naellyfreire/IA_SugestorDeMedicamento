# -*- coding: utf-8 -*-
"""IA

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hvW2RpIEYW028s15GxAcHeecDpc0-hq9

Equipe:
Josué Lamec Vasconcelos Silva - 473547,
Ana Márcia de Lima - 497437,
Antônia Naelly Freire de Lima - 493823.

Escolha da base de dados:
A base de dados escolhida é um conjunto de dados de revisão de medicamentos "Drug Review Dataset (Drugs.com)"  que apresenta avaliações de usuários sobre medicamentos, incluindo informações sobre o nome do medicamento, condição médica, avaliação do tratamento, comentários e outros atributos relacionados. O conjunto de dados fornece análises de pacientes sobre medicamentos específicos, juntamente com condições relacionadas e uma classificação de 10 estrelas, refletindo a satisfação geral do paciente. Os dados foram obtidos rastreando sites de revisão farmacêutica online.

Link da base de dados: https://archive.ics.uci.edu/dataset/462/drug+review+dataset+drugs+com

Problema escolhido:
Para o trabalho da disciplina, a equipe decidiu criar um algoritmo que recebe uma doença do usuário e sugere remédios para o seu tratamento, presentes na base de dados de acordo com o comentário feito sobre o respectivo remédio e sua avaliação.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore", category=FutureWarning)
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import LabelEncoder
from google.colab import drive
drive.mount('/content/drive', force_remount=True)
from tabulate import tabulate
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix, classification_report
from sklearn.ensemble import RandomForestClassifier

# Os dados baixados através da base escolhida já vieram com o conjunto de teste e treinamento separados
# Caso queira executar na sua máquina, por favor, acesse o seguinte link: https://archive.ics.uci.edu/dataset/462/drug+review+dataset+drugs+com
# Após fazer o download do conjunto de treino e de teste, adicione uma pasta no seu Google Drive chamda de IA e dentro da pasta adicione os dois arquivos
training_file_path = '/content/drive/MyDrive/IA/drugsComTrain_raw.tsv'
test_file_path = '/content/drive/MyDrive/IA/drugsComTest_raw.tsv'

training_df = pd.read_csv(training_file_path, delimiter='\t')
test_df = pd.read_csv(test_file_path, delimiter='\t')

training_df
#drugName é o nome do remédio
#condition é para que o remédio foi utilizado
#review é o comentário sobre a utilização
#rating é a nota de avaliação
#date é a data do registro
#usefulCount é a quantidade de usuários que acharam essa avaliação útil

#pré-processamento

#vamos remover a coluna unnamed, review e date porque não iremos utilizar
training_df.drop(['Unnamed: 0', 'review', 'date'], axis=1, inplace=True)
test_df.drop(['Unnamed: 0', 'review', 'date'], axis=1, inplace=True)

training_df

# Remove as linhas duplicadas
training_df = training_df.drop_duplicates()
test_df = test_df.drop_duplicates()

# Foi observado que em algumas linhas, há na coluna "Condition" (Doença) o seguinte texto "</span> users found this comment helpful.", o que se faz necessário excluir essas linhas da base

# Converter os valores da coluna 'condition' em strings
training_df['condition'] = training_df['condition'].astype(str)
test_df['condition'] = test_df['condition'].astype(str)

# Remover linha em que 'condition' contém a frase "users found this comment helpful."
training_df = training_df[~training_df['condition'].str.contains("users found this comment helpful.")]
test_df = test_df[~test_df['condition'].str.contains("users found this comment helpful.")]

#Removendo os dados onde a doença é nan e Not Listed / Othe
training_df = training_df[~training_df['condition'].isin(['nan', 'Not Listed / Othe'])]
test_df = test_df[~test_df['condition'].isin(['nan', 'Not Listed / Othe'])]

#Renomear as colunas da tabela dos dados de treinamento
training_df['ID'] = training_df.reset_index().index
training_df = training_df.rename(columns={'drugName': 'Medicamento'})
training_df = training_df.rename(columns={'condition': 'Doença'})
training_df = training_df.rename(columns={'rating': 'Avaliação'})
training_df = training_df.rename(columns={'usefulCount': 'Utilidade da Avaliação'})
training_df.head()

#Renomeando as colunas das tabelas dos dados de teste
test_df['ID'] = test_df.reset_index().index
test_df = test_df.rename(columns={'drugName': 'Medicamento'})
test_df = test_df.rename(columns={'condition': 'Doença'})
test_df = test_df.rename(columns={'rating': 'Avaliação'})
test_df = test_df.rename(columns={'usefulCount': 'Utilidade da Avaliação'})
test_df.head()

# Agrupando os medicamentos por doença e contando o número de medicamentos únicos
medicamentos_por_doenca_training = training_df.groupby('Doença')['Medicamento'].nunique()

# Ordenando os valores em ordem decrescente
medicamentos_por_doenca_training = medicamentos_por_doenca_training.sort_values(ascending=False)

print(medicamentos_por_doenca_training)

# Agrupando os medicamentos por doença e contando o número de medicamentos únicos
medicamentos_por_doenca_test = test_df.groupby('Doença')['Medicamento'].nunique()

# Ordenando os valores em ordem decrescente
medicamentos_por_doenca_test = medicamentos_por_doenca_test.sort_values(ascending=False)

print(medicamentos_por_doenca_test)

#agora é possível ver que os dados onde o remédio era nan ou Not Listed / Othe foram apagados

#Explorando doenças mais comuns e medicamentos mais comuns (20)

doencas_count = training_df['Doença'].value_counts().head(20)

# Crie o gráfico de barras
fig, ax = plt.subplots(figsize=(10, 6))
doencas_count.plot(kind='bar')

# Adicione a quantidade exata em cada barra
for i, v in enumerate(doencas_count):
    ax.annotate(str(v), (i, v), ha='center', va='bottom')

plt.xlabel('Doença')
plt.ylabel('Quantidade')
plt.title('Doenças mais comuns')
plt.xticks(rotation=45)
plt.show()

medicamentos_count = training_df['Medicamento'].value_counts().head(10)

# Crie o gráfico de barras
fig, ax = plt.subplots(figsize=(10, 6))
medicamentos_count.plot(kind='bar')

# Adicione a quantidade exata em cada barra
for i, v in enumerate(medicamentos_count):
    ax.annotate(str(v), (i, v), ha='center', va='bottom')

plt.xlabel('Medicamento')
plt.ylabel('Quantidade')
plt.title('Medicamentos mais comuns')
plt.xticks(rotation=45)
plt.show()

# Agrupando os dados por doença e calculando as estatísticas resumidas da utilidade da avaliação
estatisticas_utilidade_training = training_df.groupby('Doença')['Utilidade da Avaliação'].agg(['mean', 'median', 'count'])

# Exiba as estatísticas resumidas
print(estatisticas_utilidade_training)

# Agrupando os dados por nome do medicamento e calculando as estatísticas resumidas da utilidade da avaliação
estatisticas_utilidade_test = test_df.groupby('Medicamento')['Utilidade da Avaliação'].agg(['mean', 'median', 'count'])

# Exiba as estatísticas resumidas
print(estatisticas_utilidade_test)

# Contagem de avaliações por doença no conjunto de treinamento
avaliacoes_por_doenca = training_df.groupby('Doença').size()

# Filtra o dataframe para manter apenas as linhas com mais de 100 avaliações por doença
doencas_frequentes = avaliacoes_por_doenca[avaliacoes_por_doenca >= 100].index
training_df = training_df[training_df['Doença'].isin(doencas_frequentes)]

# Contagem de avaliações por doença no conjunto de teste
avaliacoes_por_doenca_teste = test_df.groupby('Doença').size()

# Filtra o dataframe de teste para manter apenas as linhas com mais de 100 avaliações por doença
doencas_frequentes_teste = avaliacoes_por_doenca_teste[avaliacoes_por_doenca_teste >= 100].index
test_df = test_df[test_df['Doença'].isin(doencas_frequentes_teste)]

# Divisão dos dados em features e target
features = training_df[['ID', 'Avaliação', 'Utilidade da Avaliação']]
target = training_df['Medicamento']

print(features)

# Divisão dos dados
features = ['ID','Avaliação', 'Utilidade da Avaliação']
X_train = training_df[features]
y_train = training_df['Medicamento']

# Treinamento do modelo
model = DecisionTreeClassifier()
model.fit(X_train, y_train)

# Medidas de desempenho do modelo
X_test = test_df[features]
y_test = test_df['Medicamento']

y_pred = model.predict(X_test)

print(accuracy_score(y_test, y_pred))
print(precision_score(y_test, y_pred, average='macro'))
print(recall_score(y_test, y_pred, average='macro'))
print(f1_score(y_test, y_pred, average='macro'))
print(confusion_matrix(y_test, y_pred))

# Recomendação do medicamento para uma doença específica

# Suponha que você queira recomendar um medicamento para a doença "Doença X" com avaliação 8 e utilidade da avaliação 20
doenca = 0
avaliacao = 8.0
utilidade = 10

# Cria um dataframe com as características da doença específica
dados_recomendacao = pd.DataFrame({'ID': [doenca],'Avaliação': [avaliacao], 'Utilidade da Avaliação': [utilidade]})

# Faz a previsão do medicamento adequado com base nas características fornecidas
medicamento_recomendado = model.predict(dados_recomendacao)

print("Medicamento recomendado:", medicamento_recomendado)

"""Após analisar os dados obtidos como resultado, vimos que a Acurácia, que é uma medida utilizada para calcular a performance geral do modelo, foi baixa. O que indica que dentre as classificações, o modelo não conseguiu indicar corretamente a maioria dos registros. A Precisão, que indica as corretas classificações positivas, o Recall que indica o valor esperado positivo correto e o F1-Score que indica a média harmônica também mostraram baixos resultados."""